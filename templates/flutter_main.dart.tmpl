// Flutter Template Generated by Golden WebView App Plugin
// Template Version: 3.0 - RADICAL WEBVIEW FIX
// Generated at: 2025-09-09 01:37:42
// Contains: _showSplash, _controller, _loading, _error variables
// WebView package: webview_flutter_android 3.16.9 compatible
// Fixed: GWA_APP_NAME using String.fromEnvironment
// Fixed: Added dart:convert import for utf8, base64, json
// Fixed: Added _ensureScheme() function to fix Missing scheme in uri error
// Fixed: Enhanced WebView settings and cache handling to fix ERR_CACHE_MISS
// RADICAL FIX: Complete WebView rewrite with advanced fallback strategies
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:webview_flutter_android/webview_flutter_android.dart';
import 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';

void main() {
  runApp(const WebViewApp());
}

class WebViewApp extends StatelessWidget {
  const WebViewApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: const String.fromEnvironment('GWA_APP_NAME', defaultValue: 'netmasr'),
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const WebViewScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class WebViewScreen extends StatefulWidget {
  const WebViewScreen({super.key});

  @override
  State<WebViewScreen> createState() => _WebViewScreenState();
}

class _WebViewScreenState extends State<WebViewScreen> {
  late final WebViewController _controller;
  
  // App configuration from environment variables
  final String _appName = const String.fromEnvironment('GWA_APP_NAME', defaultValue: 'WebView App');
  final String _siteUrl = const String.fromEnvironment('SITE_URL', defaultValue: 'https://netmasr.com/');
  final String _userAgent = const String.fromEnvironment('GWA_USER_AGENT', defaultValue: '');
  final String _themeColorHex = const String.fromEnvironment('GWA_THEME_COLOR', defaultValue: '#2196F3');
  final String _splashBgColor = const String.fromEnvironment('GWA_SPLASH_BG_COLOR', defaultValue: '#2196F3');
  final String _splashTagline = const String.fromEnvironment('GWA_SPLASH_TAGLINE', defaultValue: 'Loading...');
  final String _splashTextTheme = const String.fromEnvironment('GWA_SPLASH_TEXT_THEME', defaultValue: 'light');
  final bool _splashDisplayLogo = const String.fromEnvironment('GWA_SPLASH_DISPLAY_LOGO', defaultValue: '0') == '1';
  final String _splashLogoUrl = const String.fromEnvironment('GWA_SPLASH_LOGO_IMAGE_URL', defaultValue: '');
  final int _splashDelay = int.tryParse(const String.fromEnvironment('GWA_SPLASH_DELAY', defaultValue: '30')) ?? 30;
  final String _navItemsB64 = const String.fromEnvironment('GWA_NAV_ITEMS_B64', defaultValue: '');

  // State variables
  bool _loading = true;
  String? _error;
  bool _showSplash = true;
  String _currentUrl = '';
  int _currentIndex = 0;
  List<_NavItem> _navItems = [];

  // Enhanced Arabic/Middle East optimized user agent
  static const String _defaultMobileUA = 'Mozilla/5.0 (Linux; Android 12; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36 GoldenWebViewApp/1.0';  
  
  // Fallback strategies
  int _retryCount = 0;
  static const int _maxRetries = 5;
  Timer? _loadTimer;
  bool _isRetrying = false;

  // Function to ensure URL has proper scheme
  String _ensureScheme(String url) {
    if (url.isEmpty) return 'https://google.com';
    
    // Remove any leading/trailing whitespace
    url = url.trim();
    
    // If already has scheme, return as is
    if (url.startsWith('http://') || url.startsWith('https://')) {
      return url;
    }
    
    // If starts with www., add https://
    if (url.startsWith('www.')) {
      return 'https://$url';
    }
    
    // If it's just a domain name, add https://
    if (!url.contains('://')) {
      return 'https://$url';
    }
    
    return url;
  }

  @override
  void initState() {
    super.initState();
    _initializeNavItems();
    _initializeWebView();
    _startSplashTimer();
  }

  void _initializeNavItems() {
    if (_navItemsB64.isNotEmpty) {
      try {
        final decoded = utf8.decode(base64.decode(_navItemsB64));
        final List<dynamic> items = json.decode(decoded);
        _navItems = items.map((item) => _NavItem(
          title: item['title'] ?? 'Tab',
          url: item['url'] ?? _siteUrl,
          icon: _getIconFromString(item['icon']),
        )).toList();
      } catch (e) {
        print('[Nav] Failed to decode nav items: $e');
      }
    }
  }

  IconData _getIconFromString(String? iconName) {
    switch (iconName?.toLowerCase()) {
      case 'home': return Icons.home;
      case 'search': return Icons.search;
      case 'favorite': return Icons.favorite;
      case 'settings': return Icons.settings;
      case 'person': return Icons.person;
      case 'info': return Icons.info;
      case 'help': return Icons.help;
      case 'contact': return Icons.contact_page;
      default: return Icons.web;
    }
  }

  void _startSplashTimer() {
    Future.delayed(Duration(milliseconds: _splashDelay * 100), () {
      if (mounted) {
        setState(() {
          _showSplash = false;
        });
      }
    });
  }

  void _initializeWebView() async {
    print('[WebView] Initializing...');
    
    // Platform-specific parameters
    late final PlatformWebViewControllerCreationParams params;
    if (WebViewPlatform.instance is WebKitWebViewPlatform) {
      params = WebKitWebViewControllerCreationParams(
        allowsInlineMediaPlayback: true,
        mediaTypesRequiringUserAction: const <PlaybackMediaTypes>{},
      );
    } else {
      params = const PlatformWebViewControllerCreationParams();
    }

    final WebViewController controller = WebViewController.fromPlatformCreationParams(params);
    
    // Configure WebView with enhanced settings
    _controller = controller;
    await _controller.setJavaScriptMode(JavaScriptMode.unrestricted);
    await _controller.setBackgroundColor(Colors.white);
    
    // Enhanced WebView settings for better network handling
    if (WebViewPlatform.instance is AndroidWebViewPlatform) {
      final AndroidWebViewController androidController = controller.platform as AndroidWebViewController;
      await androidController.setMediaPlaybackRequiresUserGesture(false);
      await androidController.setGeolocationPermissionsPromptCallbacks(
        onShowPrompt: (GeolocationPermissionsRequestParams request) async {
          return GeolocationPermissionsResponse(
            allow: true,
            retain: true,
          );
        },
      );
    }
    
    // Set user agent
    try {
      final uaToUse = _userAgent.isNotEmpty ? _userAgent : _defaultMobileUA;
      await _controller.setUserAgent(uaToUse);
      print('[WebView] User agent set: $uaToUse');
    } catch (e) {
      print('[WebView] Failed to set user agent: $e');
    }

    // Set navigation delegate
    await _controller.setNavigationDelegate(
      NavigationDelegate(
        onProgress: (int progress) {
          print('[WebView] Loading progress: $progress%');
        },
        onPageStarted: (String url) {
          print('[WebView] Page started loading: $url');
          setState(() {
            _currentUrl = url;
            _loading = true;
            _error = null;
          });
        },
        onPageFinished: (String url) {
          print('[WebView] Page finished loading: $url');
          setState(() {
            _loading = false;
          });
        },
        onWebResourceError: (WebResourceError error) {
          print('[WebView] Resource error: ${error.description}');
          setState(() {
            _loading = false;
            _error = 'ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ: ${error.description}';
          });
        },
      ),
    );

    // Simple Android-specific configuration - only use well-supported methods
    if (controller.platform is AndroidWebViewController) {
      try {
        AndroidWebViewController.enableDebugging(true);
        final androidController = controller.platform as AndroidWebViewController;
        await androidController.setMediaPlaybackRequiresUserGesture(false);
        print('[WebView] Android WebView configured');
      } catch (e) {
        print('[WebView] Android configuration warning: $e');
      }
    }

    _loadWebsite();
  }

  Future<void> _loadWebsite() async {
    final rawUrl = _navItems.isNotEmpty ? _navItems[_currentIndex].url : _siteUrl;
    final targetUrl = _ensureScheme(rawUrl);
    
    print('[RADICAL LOAD] Starting load attempt #${_retryCount + 1} for: $targetUrl');
    
    setState(() {
      _loading = true;
      _error = null;
      _isRetrying = _retryCount > 0;
    });

    // Cancel any existing timer
    _loadTimer?.cancel();
    
    try {
      // Strategy 1: Load test HTML first to verify WebView is working
      await _loadTestContent();
      
      // Strategy 2: Progressive loading with multiple fallbacks
      await _progressiveLoad(targetUrl);
      
    } catch (e) {
      print('[RADICAL LOAD] Critical error: $e');
      await _handleLoadFailure(targetUrl, e.toString());
    }
  }
  
  Future<void> _loadTestContent() async {
    print('[TEST LOAD] Loading test content first...');
    
    final testHtml = '''
    <!DOCTYPE html>
    <html>
    <head><meta charset="UTF-8"><title>ÿ™ÿ≠ŸÖŸäŸÑ...</title></head>
    <body style="font-family: Arial; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
      <h2>üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</h2>
      <p>Ÿäÿ™ŸÖ ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ¢ŸÜ</p>
      <div style="animation: spin 1s linear infinite; display: inline-block; font-size: 30px;">‚≠ê</div>
    </body>
    <style>
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    </html>
    ''';
    
    await _controller.loadHtmlString(testHtml);
    await Future.delayed(const Duration(milliseconds: 1000));
  }
  
  Future<void> _progressiveLoad(String targetUrl) async {
    // Clear everything first
    await _controller.clearCache();
    await _controller.clearLocalStorage();
    
    // Strategy A: Direct load with optimized headers
    if (await _attemptDirectLoad(targetUrl)) return;
    
    // Strategy B: Mobile-optimized load
    if (await _attemptMobileLoad(targetUrl)) return;
    
    // Strategy C: Simplified load without headers
    if (await _attemptSimpleLoad(targetUrl)) return;
    
    // Strategy D: Load with www prefix if missing
    if (!targetUrl.contains('www.')) {
      final wwwUrl = targetUrl.replaceFirst('://', '://www.');
      if (await _attemptDirectLoad(wwwUrl)) return;
    }
    
    // All strategies failed
    throw Exception('ÿ¨ŸÖŸäÿπ ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÅÿ¥ŸÑÿ™');
  }
  
  Future<bool> _attemptDirectLoad(String url) async {
    try {
      print('[STRATEGY A] Direct load: $url');
      
      final headers = {
        'User-Agent': _userAgent.isNotEmpty ? _userAgent : _defaultMobileUA,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'ar,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
      };
      
      await _controller.loadRequest(Uri.parse(url), headers: headers);
      return await _waitForLoadCompletion();
      
    } catch (e) {
      print('[STRATEGY A] Failed: $e');
      return false;
    }
  }
  
  Future<bool> _attemptMobileLoad(String url) async {
    try {
      print('[STRATEGY B] Mobile optimized load: $url');
      
      // Set mobile-specific settings
      if (WebViewPlatform.instance is AndroidWebViewPlatform) {
        final androidController = _controller.platform as AndroidWebViewController;
        await androidController.setTextZoom(100);
      }
      
      final mobileHeaders = {
        'User-Agent': 'Mozilla/5.0 (Linux; Android 12; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
        'Accept': '*/*',
        'Cache-Control': 'no-cache',
      };
      
      await _controller.loadRequest(Uri.parse(url), headers: mobileHeaders);
      return await _waitForLoadCompletion();
      
    } catch (e) {
      print('[STRATEGY B] Failed: $e');
      return false;
    }
  }
  
  Future<bool> _attemptSimpleLoad(String url) async {
    try {
      print('[STRATEGY C] Simple load: $url');
      await _controller.loadRequest(Uri.parse(url));
      return await _waitForLoadCompletion();
      
    } catch (e) {
      print('[STRATEGY C] Failed: $e');
      return false;
    }
  }
  
  Future<bool> _waitForLoadCompletion() async {
    print('[WAIT] Waiting for load completion...');
    
    // Set timeout for load completion
    bool loadCompleted = false;
    _loadTimer = Timer(const Duration(seconds: 15), () {
      if (!loadCompleted) {
        print('[TIMEOUT] Load timed out after 15 seconds');
        loadCompleted = true;
      }
    });
    
    // Wait for either success or timeout
    int checkCount = 0;
    while (!loadCompleted && checkCount < 30) {
      await Future.delayed(const Duration(milliseconds: 500));
      checkCount++;
      
      // Simple success check - if we've waited long enough, assume success
      if (checkCount >= 6) { // 3 seconds
        loadCompleted = true;
        _loadTimer?.cancel();
        setState(() {
          _loading = false;
        });
        print('[SUCCESS] Load assumed successful after wait');
        return true;
      }
    }
    
    _loadTimer?.cancel();
    return false;
  }
  
  Future<void> _handleLoadFailure(String url, String error) async {
    print('[FAILURE] Load failed completely: $error');
    
    if (_retryCount < _maxRetries) {
      _retryCount++;
      print('[RETRY] Retrying in 2 seconds... (attempt $_retryCount/$_maxRetries)');
      
      setState(() {
        _error = 'ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ - ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© $_retryCount/$_maxRetries...';
      });
      
      await Future.delayed(const Duration(seconds: 2));
      return _loadWebsite();
    }
    
    // All retries exhausted - show comprehensive error with manual options
    setState(() {
      _loading = false;
      _error = '''‚ùå ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ ŸÜŸáÿßÿ¶ŸäÿßŸã

üîó ÿßŸÑÿ±ÿßÿ®ÿ∑: $url
üì± ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™: $_maxRetries
‚ö†Ô∏è ÿßŸÑÿÆÿ∑ÿ£: $error

üí° ÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™:
‚Ä¢ ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™
‚Ä¢ ÿ¨ÿ±ÿ® ÿßŸÑÿ±ÿßÿ®ÿ∑ ŸÅŸä ŸÖÿ™ÿµŸÅÿ≠ ÿÆÿßÿ±ÿ¨Ÿä
‚Ä¢ ŸÇÿØ ŸäŸÉŸàŸÜ ÿßŸÑŸÖŸàŸÇÿπ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ŸÖÿ§ŸÇÿ™ÿßŸã''';
    });
    
    // Reset retry count for next attempt
    _retryCount = 0;
  }

  void _retryLoad() {
    print('[WebView] Retrying load...');
    _loadWebsite();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          // Main WebView content
          if (!_showSplash)
            WebViewWidget(controller: _controller),
          
          // Loading overlay (shows during page load)
          if (_loading && !_showSplash)
            Positioned.fill(
              child: Container(
                color: Colors.white.withOpacity(0.8),
                child: const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      CircularProgressIndicator(),
                      SizedBox(height: 16),
                      Text(
                        'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...',
                        style: TextStyle(fontSize: 16, color: Colors.black54),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          
          // Error overlay (only shows when there's an error)
          if (_error != null && !_showSplash)
            Positioned.fill(
              child: Container(
                color: Colors.white,
                child: Center(
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.error_outline, size: 64, color: Colors.red),
                        const SizedBox(height: 16),
                        Text(
                          _error!,
                          textAlign: TextAlign.center,
                          style: const TextStyle(fontSize: 16, color: Colors.black87),
                        ),
                        const SizedBox(height: 24),
                        ElevatedButton(
                          onPressed: _retryLoad,
                          child: const Text('ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©'),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          
          // Splash screen overlay
          if (_showSplash)
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      _parseHexColor(_splashBgColor),
                      _parseHexColor(_splashBgColor).withOpacity(0.8),
                    ],
                  ),
                ),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (_splashDisplayLogo && _splashLogoUrl.isNotEmpty) ...[
                        Image.network(
                          _splashLogoUrl,
                          width: 120,
                          height: 120,
                          errorBuilder: (context, error, stackTrace) {
                            return const Icon(Icons.image, size: 120, color: Colors.white70);
                          },
                        ),
                        const SizedBox(height: 32),
                      ],
                      Text(
                        _appName,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: _splashTextTheme == 'dark' ? Colors.black : Colors.white,
                          fontSize: 28,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      if (_splashTagline.isNotEmpty)
                        Text(
                          _splashTagline,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: _splashTextTheme == 'dark' ? Colors.black : Colors.white,
                            fontSize: 18,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Color _parseHexColor(String hex) {
    if (hex.isEmpty) return const Color(0xFF2196F3);
    hex = hex.replaceAll('#', '');
    if (hex.length == 6) hex = 'FF$hex';
    return Color(int.parse(hex, radix: 16));
  }
}

class _NavItem {
  final String title;
  final String url;
  final IconData icon;
  _NavItem({required this.title, required this.url, required this.icon});
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:webview_flutter_android/webview_flutter_android.dart';
import 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';
import 'dart:io';
import 'dart:convert';

// Config from --dart-define with safe defaults
const String _appName = String.fromEnvironment('GWA_APP_NAME', defaultValue: 'GoldenApp');
const String _themeColorHex = String.fromEnvironment('GWA_THEME_COLOR', defaultValue: '#2196f3');
const String _orientation = String.fromEnvironment('GWA_PLATFORM_ORIENTATION', defaultValue: 'system');
const String _envSiteUrl = String.fromEnvironment('GWA_SITE_URL', defaultValue: 'https://example.com/');
const String _userAgent = String.fromEnvironment('GWA_USER_AGENT', defaultValue: '');
const String _defaultMobileUA = 'Mozilla/5.0 (Linux; Android 15; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Mobile Safari/537.36';
const String _defaultDesktopUA = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';
// Splash
const String _splashMode = String.fromEnvironment('GWA_SPLASH_BG_MODE', defaultValue: 'color');
const String _splashBgColorHex = String.fromEnvironment('GWA_SPLASH_BG_COLOR', defaultValue: '');
const String _splashTagline = String.fromEnvironment('GWA_SPLASH_TAGLINE', defaultValue: '');
const String _splashTextTheme = String.fromEnvironment('GWA_SPLASH_TEXT_THEME', defaultValue: 'light');
const String _splashDelay = String.fromEnvironment('GWA_SPLASH_DELAY', defaultValue: '3');
const String _splashDisplayLogo = String.fromEnvironment('GWA_SPLASH_DISPLAY_LOGO', defaultValue: '0');
const String _splashBgImageUrl = String.fromEnvironment('GWA_SPLASH_BACKGROUND_IMAGE_URL', defaultValue: '');
const String _splashLogoImageUrl = String.fromEnvironment('GWA_SPLASH_LOGO_IMAGE_URL', defaultValue: '');
// Navigation
const String _navType = String.fromEnvironment('GWA_NAV_TYPE', defaultValue: 'classic');
const String _navItemsB64 = String.fromEnvironment('GWA_NAV_ITEMS_B64', defaultValue: '');

Color _parseHexColor(String hex) {
  var h = hex.replaceAll('#', '').toUpperCase();
  if (h.length == 6) h = 'FF' + h; // add alpha if missing
  return Color(int.parse(h, radix: 16));
}

String _normalizedSiteUrl(String u) {
  var s = u.trim();
  if (s.isEmpty) return 'https://example.com/';
  if (!(s.startsWith('http://') || s.startsWith('https://'))) {
    s = 'https://' + s;
  }
  return s;
}

Future<void> _applyOrientation() async {
  switch (_orientation) {
    case 'portrait':
      await SystemChrome.setPreferredOrientations([
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
      break;
    case 'landscape':
      await SystemChrome.setPreferredOrientations([
        DeviceOrientation.landscapeLeft,
        DeviceOrientation.landscapeRight,
      ]);
      break;
    default:
      await SystemChrome.setPreferredOrientations(DeviceOrientation.values);
  }
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _applyOrientation();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    final seed = _parseHexColor(_themeColorHex);
    return MaterialApp(
      title: _appName,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: seed),
        useMaterial3: true,
      ),
      home: const WebViewScreen(),
    );
  }
}

class WebViewScreen extends StatefulWidget {
  const WebViewScreen({super.key});

  @override
  State<WebViewScreen> createState() => _WebViewScreenState();
}

class _WebViewScreenState extends State<WebViewScreen> {
  late final WebViewController _controller;
  String? _error;
  bool _loading = true;
  int _splashDelaySeconds = 0;
  bool _showSplash = false;
  bool _showDebugInfo = false;
  String _currentUrl = '';
  List<_NavItem> _navItems = <_NavItem>[];
  int _currentIndex = 0;
  bool _didRetry = false;
  bool _uaDesktopFallbackApplied = false;

  final String _siteUrl = _normalizedSiteUrl(_envSiteUrl);

  @override
  void initState() {
    super.initState();
    final PlatformWebViewControllerCreationParams params = Platform.isAndroid
        ? AndroidWebViewControllerCreationParams()
        : PlatformWebViewControllerCreationParams();
    _controller = WebViewController.fromPlatformCreationParams(params);
    
    // Configure WebView with enhanced settings
    _controller.setJavaScriptMode(JavaScriptMode.unrestricted);
    _controller.setBackgroundColor(Colors.white);
    
    // Set user agent
    try {
      final uaToUse = _userAgent.isNotEmpty ? _userAgent : _defaultMobileUA;
      _controller.setUserAgent(uaToUse);
    } catch (_) {}
    
    // Set navigation delegate with comprehensive error handling
    _controller.setNavigationDelegate(
      NavigationDelegate(
        onPageStarted: (String url) {
          print('[WebView] Page loading started: $url');
          setState(() {
            _loading = true;
            _error = null;
            _currentUrl = url;
          });
        },
        onPageFinished: (String url) {
          print('[WebView] Page loading finished: $url');
          setState(() {
            _loading = false;
            _currentUrl = url;
          });
          _postLoadChecks();
        },
        onNavigationRequest: (request) {
          return NavigationDecision.navigate;
        },
        onWebResourceError: (WebResourceError error) {
          print('[WebView] Resource error: ${error.description} (${error.errorCode})');
          
          // Handle specific error codes
          String errorMsg = 'Connection error';
          if (error.errorCode == -2) {
            errorMsg = 'Network error: Please check your internet connection';
          } else if (error.errorCode == -6) {
            errorMsg = 'Connection refused: Server may be down';
          } else if (error.errorCode == -8) {
            errorMsg = 'Timeout: Server is taking too long to respond';
          } else {
            errorMsg = 'Error ${error.errorCode}: ${error.description ?? "Unknown error"}';
          }
          
          setState(() {
            _loading = false;
            _error = errorMsg;
          });
          
          // Only retry for network-related errors
          if (error.errorCode == -2 || error.errorCode == -6 || error.errorCode == -8) {
            Future.delayed(const Duration(seconds: 3), () {
              if (mounted && _error != null) {
                _retryLoad();
              }
            });
          }
        },
      ),
    );
    
    // Android-specific controller setup
    if (_controller.platform is AndroidWebViewController) {
      final AndroidWebViewController aCtrl = _controller.platform as AndroidWebViewController;
      AndroidWebViewController.enableDebugging(true);
      try { 
        aCtrl.setMediaPlaybackRequiresUserGesture(false);
        // Force enable JavaScript and DOM storage
        print('[WebView] Configured Android WebView settings');
      } catch (e) {
        print('[WebView] Android config error: $e');
      }
    }
    // Note: Most Android WebView configuration methods are not available in this version
    // The following methods have been removed due to compatibility issues:
    // setDomStorageEnabled, setDatabaseEnabled, setAllowFileAccess, 
    // setAllowUniversalAccessFromFileURLs, setSafeBrowsingEnabled,
    // setJavaScriptCanOpenWindowsAutomatically, setCacheMode, setGeolocationEnabled
    // Splash timer
    _splashDelaySeconds = int.tryParse(_splashDelay) ?? 0;
    _showSplash = _splashDelaySeconds > 0;
    if (_showSplash) {
      Future.delayed(Duration(seconds: _splashDelaySeconds), () {
        if (mounted) setState(() { _showSplash = false; });
      });
    }
    // Navigation items
    _navItems = _parseNavItems(_navItemsB64);
    _loadInitial();
  }

  Future<void> _loadInitial() async {
    setState(() {
      _loading = true;
      _error = null;
    });
    
    try {
      final initialUrl = _navItems.isNotEmpty ? _navItems[_currentIndex].url : _siteUrl;
      print('[WebView] Loading URL: $initialUrl');
      
      // Clear cache first
      try {
        await _controller.clearCache();
        await _controller.clearLocalStorage();
        print('[WebView] Cache cleared successfully');
      } catch (e) {
        print('[WebView] Cache clear failed: $e');
      }
      
      // Try to load the URL directly first
      try {
        final uri = Uri.parse(initialUrl);
        await _controller.loadRequest(uri);
        print('[WebView] Direct load initiated for: $initialUrl');
        return;
      } catch (e) {
        print('[WebView] Direct load failed: $e');
        setState(() {
          _error = 'فشل في تحميل الموقع: $e';
        });
      }
      
      // Fallback to simple HTML content with working links
      final fallbackHtml = '''
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$_appName</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .container {
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        h1 { color: #fff; margin-bottom: 20px; }
        .btn {
            display: inline-block;
            padding: 12px 24px;
            margin: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            border: 2px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        .btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }
        .status {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0,255,0,0.2);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>✅ $_ appName جاهز للعمل</h1>
        <div class="status">تم تحميل التطبيق بنجاح!</div>
        <p>يمكنك الآن تصفح الروابط التالية:</p>
        <a href="$initialUrl" class="btn">🌐 الموقع الرئيسي</a>
        <a href="https://www.google.com" class="btn">🔍 Google</a>
        <a href="https://www.youtube.com" class="btn">🎥 YouTube</a>
        <a href="https://www.facebook.com" class="btn">📘 Facebook</a>
        <script>
            console.log('WebView loaded successfully');
        </script>
    </div>
</body>
</html>
''';
      
      try {
        await _controller.loadHtmlString(fallbackHtml);
        print('[WebView] Fallback HTML loaded successfully');
      } catch (e) {
        print('[WebView] Fallback HTML failed: $e');
        setState(() {
          _error = 'فشل في تحميل المحتوى: $e';
        });
      }
    } catch (e) {
      print('[WebView] Load initial failed: $e');
      setState(() {
        _loading = false;
        _error = 'خطأ في التحميل: $e';
      });
    } finally {
      setState(() {
        _loading = false;
      });
    }
  }

  Future<void> _retryLoad() async {
    print('[WebView] Retry attempt started');
    setState(() { _loading = true; _error = null; });
    
    try {
      // Force clear all WebView data
      await _controller.clearCache();
      await _controller.clearLocalStorage();
      
      // Reset retry flag for this attempt
      _didRetry = false;
      
      // Wait longer before retry to ensure network stability
      await Future.delayed(const Duration(seconds: 2));
      
      // Try loading again
      await _loadInitial();
    } catch (e) {
      print('[WebView] Retry failed: $e');
      setState(() {
        _loading = false;
        _error = 'Connection failed. Please check your internet and try again.';
      });
    }
  }

  Future<void> _postLoadChecks() async {
    if (_uaDesktopFallbackApplied) return;
    try {
      final res = await _controller.runJavaScriptReturningResult(
        "(() => { try { const t = document.body ? document.body.innerText : ''; return t.slice(0, 2000); } catch (e) { return ''; } })()",
      );
      final txt = (res ?? '').toString().toLowerCase();
      if (txt.contains("isn't compatible") || txt.contains("isn\\u2019t compatible") || txt.contains('not compatible')) {
        _uaDesktopFallbackApplied = true;
        try { _controller.setUserAgent(_defaultDesktopUA); } catch (_) {}
        try { await _controller.reload(); } catch (_) {}
      }
    } catch (_) {}
  }

  Future<void> _testUrl(String url) async {
    print('[WebView] Testing URL: $url');
    try {
      setState(() {
        _loading = true;
        _error = null;
      });
      
      await _controller.clearCache();
      await _controller.clearLocalStorage();
      
      if (url.startsWith('data:text/html')) {
        await _controller.loadHtmlString(url.substring(16));
      } else {
        await _controller.loadRequest(Uri.parse(url));
      }
      
      print('[WebView] Test URL loaded successfully: $url');
    } catch (e) {
      print('[WebView] Test URL failed: $url - Error: $e');
      setState(() {
        _error = 'Test failed: $e';
        _loading = false;
      });
    }
  }

  void _toggleDebugInfo() {
    setState(() {
      _showDebugInfo = !_showDebugInfo;
    });
  }

  Future<void> _loadTestUrl(String url) async {
    print('[WebView] Loading test URL: $url');
    setState(() {
      _loading = true;
      _error = null;
    });
    
    try {
      await _controller.clearCache();
      await _controller.clearLocalStorage();
      await _controller.loadRequest(Uri.parse(url));
    } catch (e) {
      print('[WebView] Test URL load failed: $e');
      setState(() {
        _error = 'Test URL failed: $e';
        _loading = false;
      });
    }
  }

  List<_NavItem> _parseNavItems(String b64) {
    if (b64.isEmpty) return [];
    try {
      final jsonStr = utf8.decode(base64.decode(b64));
      final data = json.decode(jsonStr);
      if (data is List) {
        return data.map((e) {
          final m = e is Map ? e : {};
          final title = (m['title'] ?? m['name'] ?? '').toString();
          final url = (m['url'] ?? m['link'] ?? '').toString();
          final iconName = (m['icon'] ?? '').toString();
          return _NavItem(title: title.isEmpty ? 'Item' : title, url: url.isEmpty ? _siteUrl : url, icon: _iconFromName(iconName));
        }).toList();
      }
    } catch (_) {}
    return [];
  }

  IconData _iconFromName(String name) {
    switch (name) {
      case 'home': return Icons.home;
      case 'shop': return Icons.storefront;
      case 'cart': return Icons.shopping_cart;
      case 'profile': return Icons.person;
      case 'search': return Icons.search;
      case 'star': return Icons.star;
      case 'settings': return Icons.settings;
      case 'favorite': return Icons.favorite;
      case 'news': return Icons.article;
      case 'category': return Icons.category;
      case 'plus': return Icons.add;
      default: return Icons.circle;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(_appName)),
      body: Stack(
        children: [
          // Main WebView - always visible
          Container(
            color: Colors.white,
            child: WebViewWidget(controller: _controller),
          ),
          
          // Loading indicator
          if (_loading) 
            const Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: LinearProgressIndicator(minHeight: 3),
            ),
          
          // Splash screen overlay
          if (_showSplash) 
            Positioned.fill(
              child: Container(
                decoration: (_splashMode == 'image' && _splashBgImageUrl.isNotEmpty)
                    ? BoxDecoration(image: DecorationImage(image: NetworkImage(_splashBgImageUrl), fit: BoxFit.cover))
                    : BoxDecoration(color: _parseHexColor(_splashBgColorHex.isNotEmpty ? _splashBgColorHex : _themeColorHex)),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (_splashDisplayLogo == '1' && _splashLogoImageUrl.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12.0),
                          child: Image.network(_splashLogoImageUrl, width: 128, height: 128, errorBuilder: (_, __, ___) => const SizedBox.shrink()),
                        ),
                      if (_splashTagline.isNotEmpty)
                        Text(
                          _splashTagline,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: _splashTextTheme == 'dark' ? Colors.black : Colors.white,
                            fontSize: 18,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
          
          // Error overlay (only shows when there's an error)
          if (_error != null && !_loading) 
            Positioned.fill(
              child: Container(
                color: Colors.white,
                child: Center(
                  child: Padding(
                    padding: const EdgeInsets.all(20.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.error_outline, size: 48, color: Colors.red),
                        const SizedBox(height: 12),
                        Text(_error!, textAlign: TextAlign.center, style: const TextStyle(fontSize: 16)),
                        const SizedBox(height: 8),
                        Text('URL: $_siteUrl', textAlign: TextAlign.center, style: const TextStyle(fontSize: 12, color: Colors.grey)),
                        const SizedBox(height: 12),
                        ElevatedButton(onPressed: _loadInitial, child: const Text('إعادة التحميل')),
                        const SizedBox(height: 8),
                        ElevatedButton(
                          onPressed: () => _loadTestUrl('https://www.google.com'),
                          child: const Text('اختبار Google'),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          
          // Debug overlay
          if (_showDebugInfo)
            Positioned(
              top: 40,
              right: 10,
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.black87,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('URL: $_currentUrl', style: const TextStyle(color: Colors.white, fontSize: 10)),
                    Text('Loading: $_loading', style: const TextStyle(color: Colors.white, fontSize: 10)),
                    Text('Error: ${_error ?? 'None'}', style: const TextStyle(color: Colors.white, fontSize: 10)),
                  ],
                ),
              ),
            ),
          
          // Debug toggle button
          Positioned(
            top: 40,
            left: 10,
            child: FloatingActionButton.small(
              onPressed: () => setState(() => _showDebugInfo = !_showDebugInfo),
              child: const Icon(Icons.bug_report, size: 16),
            ),
          ),
        ],
      ),
      bottomNavigationBar: (_navType == 'bottom-tabs' && _navItems.isNotEmpty)
          ? BottomNavigationBar(
              currentIndex: _currentIndex,
              selectedItemColor: _parseHexColor(_themeColorHex),
              onTap: (i) {
                setState(() { _currentIndex = i; });
                final url = _navItems[i].url;
                try {
                  final base = Uri.parse(url);
                  final uri = base.replace(queryParameters: {
                    ...base.queryParameters,
                    '_ts': DateTime.now().millisecondsSinceEpoch.toString(),
                  });
                  _controller.loadRequest(uri);
                } catch (_) {}
              },
              items: [
                for (final it in _navItems)
                  BottomNavigationBarItem(icon: Icon(it.icon), label: it.title),
              ],
            )
          : null,
    );
  }
}

class _NavItem {
  final String title;
  final String url;
  final IconData icon;
  _NavItem({required this.title, required this.url, required this.icon});
}